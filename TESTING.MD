---
weight: 121
toc: true
title: Tests during development
menu:
    docs:
        parent: contributing
lead: ""
lastmod: "2023-09-10T08:48:57+00:00"
images: []
draft: false
description: Understanding and running tests when developing Prometheus-Operator
date: "2023-09-10T00:00:00+00:00"
---

When contributing code to Prometheus-Operator, you'll notice that every Pull Request will run against an extensive test suite. Among an extensive list of benefits that tests brings to the Project's overall health and reliability, it can be the reviewer's and contributors's best friend during development:

* Test cases serve as documentation, providing insights into the expected behavior of the software.
* Testing helps prevent regressions by verifying that new changes don't break existing functionality.
* Running tests locally accelerate the feedback loop, removing the dependency that contributors might have on CI when working on a Pull Request.

This document will focus on teaching you about the different test suites that we currently have and how to run different scenarios to help you development experience!

# Test suites

## Unit tests

> Explain different unit test suites

> test short
> test long
> when to use each one

### Multiline string comparison - Golden files

Golden files are plain text files used to assist assertion of long strings. In Prometheus-Operator they are often often generated by a function to be used as part of a ConfigMap or Secret.

In the example below, we're generating the Prometheus configuration (which can easily have 100+ lines) and comparing it against a golden file:

```go
func TestAlertmanagerTimeoutConfig(t *testing.T) {
	p := defaultPrometheus()
	p.Spec.Alerting = &monitoringv1.AlertingSpec{
		Alertmanagers: []monitoringv1.AlertmanagerEndpoints{
			{
				Name:       "alertmanager-main",
				Namespace:  "default",
				Port:       intstr.FromString("web"),
				APIVersion: "v2",
				Timeout:    (*monitoringv1.Duration)(ptr.To("60s")),
			},
		},
	}

	cg := mustNewConfigGenerator(t, p)
	cfg, err := cg.GenerateServerConfiguration(
		context.Background(),
		p.Spec.EvaluationInterval,
		p.Spec.QueryLogFile,
		p.Spec.RuleSelector,
		p.Spec.Exemplars,
		p.Spec.TSDB,
		p.Spec.Alerting,
		p.Spec.RemoteRead,
		nil,
		nil,
		nil,
		nil,
		&assets.Store{},
		nil,
		nil,
		nil,
		nil,
	)
	require.NoError(t, err)
	golden.Assert(t, string(cfg), "AlertmanagerTimeoutConfig.golden")
}
```

The usage of golden files help us maintain test suites with several multiline strings comparison without sacrifing test readability.

### Updating Golden Files

There are contributions, e.g. adding a new required field to an existing configuration, that requires us to update several golden files at once. This can easily be done with the command below:

```
make test-unit-update-golden
```

## End-to-end tests

> When to use them

> Running locally

> Skipping tests to accelerate development feedback loop
